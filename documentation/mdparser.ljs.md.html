<h2>Literate</h2>

<p><strong>note:</strong> you should view this file in something that allows github flavored markdown style code blocks.</p>

<p>Viewing in <a href="http://jbt.github.io/markdown-editor/">markdown-editor</a> works quite well.</p>

<h3>Basics</h3>

<p>This project comprises a few ideas.</p>

<ol><li>A basic implementation of literate programming that is as general as possible</li><li>the ability to embed &quot;documentation code&quot; that is code that is not part of your final runtime, but useful<ul><li>Inline tests into your documentation / code</li><li>Render out widgets</li><li>Apply full tools of modern web to your source code</li><li>Do so in ways that are peformant and don&#39;t mess with viewing of source (sandboxing etc.)</li></ul></li><li>A flexible and simple structure that doesn&#39;t try to do to much (reordering, custom constructs, etc.)</li></ol>

<h3>Code</h3>

<h5>Dependencies</h5>

<p><code></code>`javascript
var fs = require(&quot;fs&quot;),
    markdown = require( &quot;markdown&quot; ).markdown,
    Promise = require(&#39;rsvp&#39;).Promise,
    _ = require(&quot;underscore&quot;);</p>

<p><code></code>`</p>

<h5>Useful variables</h5>

<p><code>regex</code> is currently just meant for <a href="https://help.github.com/articles/github-flavored-markdown">github flavored markdown</a> style fenced code. I also want to very soon support 4 space indentation style. </p>

<p><code>javascript
var regex = /(={3,}\n)?`{3}/g;
</code></p>

<p>The <code>map</code> of markdown syntax name types to extensions, will add more <a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">types</a> later. I want to play with <a href="https://www.npmjs.org/package/highlight">highlight.js</a> and see how its auto language detection code could work to prevent having to explicitly tag with code types (untagged code currently falls back to being javascript, could make it pull from a reverse map of <code>map</code> against the filename, that is file.ljs -&gt; literate js).</p>

<p>Only web languages will work as documentation code (here being documentation code means being *-page)
<code>javascript
var map = {
  &quot;javascript&quot;: &quot;js&quot;,
  &quot;CSS&quot;: &quot;css&quot;,
  &quot;HTML&quot;: &quot;html&quot;
};
</code></p>

<p>===
<code>
console.log(&quot;hello world&quot;);
</code></p>

<h4>Parser</h4>

<p>This is where the rubber hits the road. This is a constructor function which takes in three arguments. <code>filename</code> is simply the name of the file you are translating, this may have to be more flexible to handle directories later. <code>watch</code> determines whether or not to continue watching file for changes. <code>generateHtml</code> will cause it to render out the markdown, as well as output the documentation code. </p>

<p>Some desirable changes:</p>

<ul><li>allow passing an output name to write to</li><li>write html + documentation code to a directory that can be published easily</li><li>make sure the parser reveals what it does to more advanced usage</li><li>abstract out file actions so we can also parse documents on client side. For example have a button that on click saves parsed js to clipboard</li><li>build preview viewer. Just a simple node server with <a href="https://github.com/chjj/marked">marked</a> which opens a preivew window, or clientside just a window opening. This would have the running documentation code and update on preview</li><li>write out headers and subheaders of markdown as comments to generated file</li><li>build sourcemaps when asked to</li><li><em>MAYBE</em> support closure compiler style <a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">annotations</a> in markdown if it can be done in a pretty and reliable way</li></ul>

<p><code></code>`javascript
var mdparser = function(filename, watch, doHtml, output) {
  this.fileName = filename;
  this.output = output || filename;
  this.watch = watch;
  this.html = doHtml;</p>

<p>  if(filename) {
    this.processFile(filename);</p>

<pre><code>if(watch) {
  var that = this;
  fs.watch(filename, function(e, name) {
    that.processFile(filename);
  });
}</code></pre>

<p>  }
};</p>

<p>mdparser.prototype = {
  addFolder: function(name) {
    return new Promise(function(resolve, reject) {
      var array = name.split(&quot;/&quot;),
          fileName = array.pop();</p>

<pre><code>  array.push(&quot;documentation&quot;);
  var directory = array.join(&quot;/&quot;);

  array.push(fileName);
  var directoriedName = array.join(&quot;/&quot;);
  try {
    fs.mkdir(directory, function(err) {
      if(err &amp;&amp; err.code != &quot;EEXIST&quot;) {
        reject(err);
      } else {
        resolve(directoriedName);
      }
    });
  } catch(e) {
    console.error(&quot;addFolder error&quot;, e);
    reject(e);
  }
});</code></pre>

<p>  },
  generateHtml: function(data, filename) {
    var that = this;</p>

<pre><code>return new Promise(function(resolve, reject) {
  var html = markdown.toHTML(data);
  that.addFolder(filename).then(function(name) {
    that.write(name + &quot;.html&quot;, html).then(resolve, reject);
  });
});</code></pre>

<p>  },
  processFile: function(filename) {
    var that = this;
    return new Promise(function(resolve, reject) {
      that.read(filename).then(function(data) {
        that.operate(data, filename);
        if(that.html) {
          that.generateHtml(data, filename).then(resolve, reject);
        } else {
          resolve(true);
        }
      });
    });
  },
  read: function(filename) {
    var that = this;</p>

<pre><code>return new Promise(function(resolve, reject) {
  try {
    fs.readFile(filename, &quot;utf8&quot;, function (err, data) {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  } catch(e) {
    console.error(&quot;read error&quot;, e);
    reject(e);
  }
});</code></pre>

<p>  },
  write: function(path, data) {
    return new Promise(function(resolve, reject) {
      try {
        fs.writeFile(path, data, function(err) {
          if(err) {
            reject(err);
          } else {
            resolve(true);
          }
        });
      } catch (e) {
        console.error(&quot;write error&quot;, e);
        reject(e);
      }
    });
  },
  operate: function(data, name) {
    var parsedObject = this.parse(data),
        that = this;</p>

<pre><code>for (var key in parsedObject) {
  var parsed = parsedObject[key],</code></pre>

<p><code></code>`</p>

<p>This documentation code thing needs a serious cleanup..</p>

<p><code></code>`javascript
          documentationCode = !~~key.indexOf(&quot;page-&quot;),
          type = documentationCode ? key.substring(5) : key,
          output = name.split(&quot;.&quot;)[0] + (documentationCode ? &quot;-page&quot; : &quot;&quot;) + &quot;.&quot; + map[type];</p>

<pre><code>  if(documentationCode &amp;&amp; this.html) {
    this.addFolder(output).then(function(name) {
      that.write(name, parsed)
    });
  } else {
    that.write(output, parsed);
  }
}</code></pre>

<p>  },
<code></code>`</p>

<p>The parse function basically just loops over all occurences of our special three backticks (which I dread to name until it only checks at the beginning of lines) and counts itself in and out of code blocks. This means that nested code blocks will <strong>absolutely not work</strong>. </p>

<p>This code is a little verbose right now, but I&#39;m hopeful that at least its relatively easy to follow and understand the idea. Striving for something approaching obvious correctness at the cost of no fancy coding and complex regexs.</p>

<p><code></code>`javascript
  parse: function(file) {
    var myArray,
        result = {},
        inCode = false,
        documentationCode = false,
        type,
        codeStart;</p>

<pre><code>while ((myArray = regex.exec(file)) !== null) {
  var index = myArray.index,
  	  length = myArray[0].length,
      doc = myArray[1],
      text = &quot;&quot;;

  if(!inCode) {
    index += length;
    var lineEnd = file.indexOf(&quot;\n&quot;, index);
    type = file.substring(index, lineEnd) || &quot;javascript&quot;; //change to inferred page type later
    documentationCode = doc;

    inCode = true;
    codeStart = lineEnd || index;
  } else {
    text = file.substring(codeStart, index);
    if(text.length) {
      if(documentationCode) {
        type = &quot;page-&quot; + type;
      }
      if(result[type]) {
        result[type] += text;
      } else {
        result[type] = text;
      }
    }
    documentationCode = false;
    codeStart = false;
    inCode = false;
  }
}
return result;</code></pre>

<p>  }
}
<code></code>`
Send it out to the world!</p>

<p><code>javascript
module.exports = mdparser;
</code></p>